
DEMO.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  0000035e  000003d2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000035e  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  000003d2  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000404  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000068  00000000  00000000  00000444  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000a4c  00000000  00000000  000004ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000007fb  00000000  00000000  00000ef8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000044b  00000000  00000000  000016f3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000f8  00000000  00000000  00001b40  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000431  00000000  00000000  00001c38  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000035e  00000000  00000000  00002069  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000018  00000000  00000000  000023c7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3b 00 	jmp	0x76	; 0x76 <__ctors_end>
   4:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
   8:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
   c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  10:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  14:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  18:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  1c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  20:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  24:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  28:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  2c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  30:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__vector_13>
  38:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  3c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  40:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  44:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  48:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  4c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  50:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  54:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  58:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  5c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  60:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  64:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
  68:	42 01       	movw	r8, r4
  6a:	44 01       	movw	r8, r8
  6c:	46 01       	movw	r8, r12
  6e:	48 01       	movw	r8, r16
  70:	4a 01       	movw	r8, r20
  72:	51 01       	movw	r10, r2
  74:	58 01       	movw	r10, r16

00000076 <__ctors_end>:
  76:	11 24       	eor	r1, r1
  78:	1f be       	out	0x3f, r1	; 63
  7a:	cf ef       	ldi	r28, 0xFF	; 255
  7c:	d8 e0       	ldi	r29, 0x08	; 8
  7e:	de bf       	out	0x3e, r29	; 62
  80:	cd bf       	out	0x3d, r28	; 61
  82:	0e 94 9c 01 	call	0x338	; 0x338 <main>
  86:	0c 94 ad 01 	jmp	0x35a	; 0x35a <_exit>

0000008a <__bad_interrupt>:
  8a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000008e <__vector_13>:
    }

  return (0);
}
ISR(TIMER1_OVF_vect)
{
  8e:	1f 92       	push	r1
  90:	0f 92       	push	r0
  92:	0f b6       	in	r0, 0x3f	; 63
  94:	0f 92       	push	r0
  96:	11 24       	eor	r1, r1
  98:	2f 93       	push	r18
  9a:	8f 93       	push	r24
  9c:	9f 93       	push	r25
  __asm__ __volatile__ ("eor r24,r24 "); 
  9e:	88 27       	eor	r24, r24
  __asm__ __volatile__ ("LDI r24, 5"); 
  a0:	85 e0       	ldi	r24, 0x05	; 5

000000a2 <loop>:
  __asm__ __volatile__ ("loop:dec r24");
  a2:	8a 95       	dec	r24
  __asm__ __volatile__ ("brne loop"); 
  a4:	f1 f7       	brne	.-4      	; 0xa2 <loop>
 
  
  PORTB |= _BV(PB5);
  a6:	2d 9a       	sbi	0x05, 5	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  a8:	2f e7       	ldi	r18, 0x7F	; 127
  aa:	82 e4       	ldi	r24, 0x42	; 66
  ac:	90 e1       	ldi	r25, 0x10	; 16
  ae:	21 50       	subi	r18, 0x01	; 1
  b0:	80 40       	sbci	r24, 0x00	; 0
  b2:	90 40       	sbci	r25, 0x00	; 0
  b4:	e1 f7       	brne	.-8      	; 0xae <loop+0xc>
  b6:	00 c0       	rjmp	.+0      	; 0xb8 <loop+0x16>
  b8:	00 00       	nop
  _delay_ms(333);
  PORTB &= ~_BV(PB5);
  ba:	2d 98       	cbi	0x05, 5	; 5
  bc:	2f e7       	ldi	r18, 0x7F	; 127
  be:	82 e4       	ldi	r24, 0x42	; 66
  c0:	90 e1       	ldi	r25, 0x10	; 16
  c2:	21 50       	subi	r18, 0x01	; 1
  c4:	80 40       	sbci	r24, 0x00	; 0
  c6:	90 40       	sbci	r25, 0x00	; 0
  c8:	e1 f7       	brne	.-8      	; 0xc2 <loop+0x20>
  ca:	00 c0       	rjmp	.+0      	; 0xcc <loop+0x2a>
  cc:	00 00       	nop
  _delay_ms(333);
  

  ce:	9f 91       	pop	r25
  d0:	8f 91       	pop	r24
  d2:	2f 91       	pop	r18
  d4:	0f 90       	pop	r0
  d6:	0f be       	out	0x3f, r0	; 63
  d8:	0f 90       	pop	r0
  da:	1f 90       	pop	r1
  dc:	18 95       	reti

000000de <GPIO_config_output>:
#include "gpio.h"

void GPIO_config_output(volatile uint8_t *reg_name, uint8_t pin_num)
{
    *reg_name |= _BV(pin_num);
  de:	fc 01       	movw	r30, r24
  e0:	40 81       	ld	r20, Z
  e2:	21 e0       	ldi	r18, 0x01	; 1
  e4:	30 e0       	ldi	r19, 0x00	; 0
  e6:	01 c0       	rjmp	.+2      	; 0xea <GPIO_config_output+0xc>
  e8:	22 0f       	add	r18, r18
  ea:	6a 95       	dec	r22
  ec:	ea f7       	brpl	.-6      	; 0xe8 <GPIO_config_output+0xa>
  ee:	24 2b       	or	r18, r20
  f0:	20 83       	st	Z, r18
  f2:	08 95       	ret

000000f4 <GPIO_write>:

}

void GPIO_write(volatile uint8_t *reg_name, uint8_t pin_num, uint8_t pin_val)
{
  f4:	fc 01       	movw	r30, r24

if (pin_val==0)
     *reg_name &= ~_BV(pin_num); 
  f6:	80 81       	ld	r24, Z
  f8:	21 e0       	ldi	r18, 0x01	; 1
  fa:	30 e0       	ldi	r19, 0x00	; 0
  fc:	01 c0       	rjmp	.+2      	; 0x100 <GPIO_write+0xc>
  fe:	22 0f       	add	r18, r18
 100:	6a 95       	dec	r22
 102:	ea f7       	brpl	.-6      	; 0xfe <GPIO_write+0xa>
}

void GPIO_write(volatile uint8_t *reg_name, uint8_t pin_num, uint8_t pin_val)
{

if (pin_val==0)
 104:	41 11       	cpse	r20, r1
 106:	03 c0       	rjmp	.+6      	; 0x10e <GPIO_write+0x1a>
     *reg_name &= ~_BV(pin_num); 
 108:	20 95       	com	r18
 10a:	28 23       	and	r18, r24
 10c:	01 c0       	rjmp	.+2      	; 0x110 <GPIO_write+0x1c>
else 
    *reg_name |= _BV(pin_num);
 10e:	28 2b       	or	r18, r24
 110:	20 83       	st	Z, r18
 112:	08 95       	ret

00000114 <GPIO_toggle>:


void GPIO_toggle(volatile uint8_t *reg_name, uint8_t pin_num)

{
    *reg_name^=_BV(pin_num);
 114:	fc 01       	movw	r30, r24
 116:	40 81       	ld	r20, Z
 118:	21 e0       	ldi	r18, 0x01	; 1
 11a:	30 e0       	ldi	r19, 0x00	; 0
 11c:	01 c0       	rjmp	.+2      	; 0x120 <GPIO_toggle+0xc>
 11e:	22 0f       	add	r18, r18
 120:	6a 95       	dec	r22
 122:	ea f7       	brpl	.-6      	; 0x11e <GPIO_toggle+0xa>
 124:	24 27       	eor	r18, r20
 126:	20 83       	st	Z, r18
 128:	08 95       	ret

0000012a <GPIO_read>:
}
uint8_t GPIO_read(volatile uint8_t *reg_name, uint8_t pin_num)
{
   
   return(bit_is_set(*reg_name, pin_num));
 12a:	fc 01       	movw	r30, r24
 12c:	20 81       	ld	r18, Z
 12e:	81 e0       	ldi	r24, 0x01	; 1
 130:	90 e0       	ldi	r25, 0x00	; 0
 132:	01 c0       	rjmp	.+2      	; 0x136 <GPIO_read+0xc>
 134:	88 0f       	add	r24, r24
 136:	6a 95       	dec	r22
 138:	ea f7       	brpl	.-6      	; 0x134 <GPIO_read+0xa>

}
 13a:	82 23       	and	r24, r18
 13c:	08 95       	ret

0000013e <GPIO_config_input_nopull>:

void GPIO_config_input_nopull(volatile  uint8_t *reg_name , uint8_t  pin_num)
{
 13e:	fc 01       	movw	r30, r24
    *reg_name &= ~_BV(pin_num);
 140:	80 81       	ld	r24, Z
 142:	21 e0       	ldi	r18, 0x01	; 1
 144:	30 e0       	ldi	r19, 0x00	; 0
 146:	01 c0       	rjmp	.+2      	; 0x14a <GPIO_config_input_nopull+0xc>
 148:	22 0f       	add	r18, r18
 14a:	6a 95       	dec	r22
 14c:	ea f7       	brpl	.-6      	; 0x148 <GPIO_config_input_nopull+0xa>
 14e:	20 95       	com	r18
 150:	82 23       	and	r24, r18
 152:	80 83       	st	Z, r24
     reg_name++;
    *reg_name &= ~_BV(pin_num);
 154:	81 81       	ldd	r24, Z+1	; 0x01
 156:	28 23       	and	r18, r24
 158:	21 83       	std	Z+1, r18	; 0x01
 15a:	08 95       	ret

0000015c <GPIO_config_input_pullup>:
}

void GPIO_config_input_pullup(volatile  uint8_t *reg_name , uint8_t  pin_num)
{
 15c:	fc 01       	movw	r30, r24
    *reg_name |= _BV(pin_num);
 15e:	80 81       	ld	r24, Z
 160:	21 e0       	ldi	r18, 0x01	; 1
 162:	30 e0       	ldi	r19, 0x00	; 0
 164:	01 c0       	rjmp	.+2      	; 0x168 <GPIO_config_input_pullup+0xc>
 166:	22 0f       	add	r18, r18
 168:	6a 95       	dec	r22
 16a:	ea f7       	brpl	.-6      	; 0x166 <GPIO_config_input_pullup+0xa>
 16c:	82 2b       	or	r24, r18
 16e:	80 83       	st	Z, r24
     reg_name++;
    *reg_name |= _BV(pin_num);
 170:	81 81       	ldd	r24, Z+1	; 0x01
 172:	28 2b       	or	r18, r24
 174:	21 83       	std	Z+1, r18	; 0x01
 176:	08 95       	ret

00000178 <TIM_config_prescaler>:
/* Functions ---------------------------------------------------------*/
void TIM_config_prescaler(uint8_t timer_name,
                          uint8_t presc_val)
{
    /* Timer/Counter0 */
    if (timer_name == TIM0) {
 178:	81 11       	cpse	r24, r1
 17a:	31 c0       	rjmp	.+98     	; 0x1de <TIM_config_prescaler+0x66>
        switch (presc_val) {
 17c:	63 30       	cpi	r22, 0x03	; 3
 17e:	f9 f0       	breq	.+62     	; 0x1be <TIM_config_prescaler+0x46>
 180:	50 f4       	brcc	.+20     	; 0x196 <TIM_config_prescaler+0x1e>
 182:	66 23       	and	r22, r22
 184:	79 f0       	breq	.+30     	; 0x1a4 <TIM_config_prescaler+0x2c>
 186:	61 30       	cpi	r22, 0x01	; 1
 188:	39 f5       	brne	.+78     	; 0x1d8 <TIM_config_prescaler+0x60>
                TCCR0B = TCCR0B & ~_BV(CS01);
                TCCR0B = TCCR0B |  _BV(CS00);
                break;
            case TIM_PRESC_8:
                /* 010 */
                TCCR0B = TCCR0B & ~_BV(CS02);
 18a:	85 b5       	in	r24, 0x25	; 37
 18c:	8b 7f       	andi	r24, 0xFB	; 251
 18e:	85 bd       	out	0x25, r24	; 37
                TCCR0B = TCCR0B |  _BV(CS01);
 190:	85 b5       	in	r24, 0x25	; 37
 192:	82 60       	ori	r24, 0x02	; 2
 194:	0f c0       	rjmp	.+30     	; 0x1b4 <TIM_config_prescaler+0x3c>
void TIM_config_prescaler(uint8_t timer_name,
                          uint8_t presc_val)
{
    /* Timer/Counter0 */
    if (timer_name == TIM0) {
        switch (presc_val) {
 196:	65 30       	cpi	r22, 0x05	; 5
 198:	41 f0       	breq	.+16     	; 0x1aa <TIM_config_prescaler+0x32>
 19a:	66 30       	cpi	r22, 0x06	; 6
 19c:	e9 f4       	brne	.+58     	; 0x1d8 <TIM_config_prescaler+0x60>
                TCCR0B = TCCR0B & ~_BV(CS01);
                TCCR0B = TCCR0B & ~_BV(CS00);
                break;
            case TIM_PRESC_1024:
                /* 101 */
                TCCR0B = TCCR0B |  _BV(CS02);
 19e:	85 b5       	in	r24, 0x25	; 37
 1a0:	84 60       	ori	r24, 0x04	; 4
 1a2:	13 c0       	rjmp	.+38     	; 0x1ca <TIM_config_prescaler+0x52>
    /* Timer/Counter0 */
    if (timer_name == TIM0) {
        switch (presc_val) {
            case TIM_PRESC_1:
                /* 001 */
                TCCR0B = TCCR0B & ~_BV(CS02);
 1a4:	85 b5       	in	r24, 0x25	; 37
 1a6:	8b 7f       	andi	r24, 0xFB	; 251
 1a8:	10 c0       	rjmp	.+32     	; 0x1ca <TIM_config_prescaler+0x52>
                TCCR0B = TCCR0B |  _BV(CS01);
                TCCR0B = TCCR0B |  _BV(CS00);
                break;
            case TIM_PRESC_256:
                /* 100 */
                TCCR0B = TCCR0B |  _BV(CS02);
 1aa:	85 b5       	in	r24, 0x25	; 37
 1ac:	84 60       	ori	r24, 0x04	; 4
                TCCR0B = TCCR0B & ~_BV(CS01);
                TCCR0B = TCCR0B |  _BV(CS00);
                break;
            default:
                /* 000: No clock source (Timer/Counter stopped) */
                TCCR0B = TCCR0B & ~_BV(CS02);
 1ae:	85 bd       	out	0x25, r24	; 37
                TCCR0B = TCCR0B & ~_BV(CS01);
 1b0:	85 b5       	in	r24, 0x25	; 37
 1b2:	8d 7f       	andi	r24, 0xFD	; 253
                TCCR0B = TCCR0B |  _BV(CS00);
                break;
            case TIM_PRESC_8:
                /* 010 */
                TCCR0B = TCCR0B & ~_BV(CS02);
                TCCR0B = TCCR0B |  _BV(CS01);
 1b4:	85 bd       	out	0x25, r24	; 37
                TCCR0B = TCCR0B & ~_BV(CS00);
 1b6:	85 b5       	in	r24, 0x25	; 37
 1b8:	8e 7f       	andi	r24, 0xFE	; 254
 1ba:	85 bd       	out	0x25, r24	; 37
                break;
 1bc:	08 95       	ret
            case TIM_PRESC_64:
                /* 011 */
                TCCR0B = TCCR0B & ~_BV(CS02);
 1be:	85 b5       	in	r24, 0x25	; 37
 1c0:	8b 7f       	andi	r24, 0xFB	; 251
 1c2:	85 bd       	out	0x25, r24	; 37
                TCCR0B = TCCR0B |  _BV(CS01);
 1c4:	85 b5       	in	r24, 0x25	; 37
 1c6:	82 60       	ori	r24, 0x02	; 2
 1c8:	03 c0       	rjmp	.+6      	; 0x1d0 <TIM_config_prescaler+0x58>
                TCCR0B = TCCR0B & ~_BV(CS01);
                TCCR0B = TCCR0B & ~_BV(CS00);
                break;
            case TIM_PRESC_1024:
                /* 101 */
                TCCR0B = TCCR0B |  _BV(CS02);
 1ca:	85 bd       	out	0x25, r24	; 37
                TCCR0B = TCCR0B & ~_BV(CS01);
 1cc:	85 b5       	in	r24, 0x25	; 37
 1ce:	8d 7f       	andi	r24, 0xFD	; 253
 1d0:	85 bd       	out	0x25, r24	; 37
                TCCR0B = TCCR0B |  _BV(CS00);
 1d2:	85 b5       	in	r24, 0x25	; 37
 1d4:	81 60       	ori	r24, 0x01	; 1
 1d6:	f1 cf       	rjmp	.-30     	; 0x1ba <TIM_config_prescaler+0x42>
                break;
            default:
                /* 000: No clock source (Timer/Counter stopped) */
                TCCR0B = TCCR0B & ~_BV(CS02);
 1d8:	85 b5       	in	r24, 0x25	; 37
 1da:	8b 7f       	andi	r24, 0xFB	; 251
 1dc:	e8 cf       	rjmp	.-48     	; 0x1ae <TIM_config_prescaler+0x36>
                TCCR0B = TCCR0B & ~_BV(CS01);
                TCCR0B = TCCR0B & ~_BV(CS00);
        }
    }
    /* Timer/Counter1 */
    else if (timer_name == TIM1) {
 1de:	81 30       	cpi	r24, 0x01	; 1
 1e0:	09 f0       	breq	.+2      	; 0x1e4 <TIM_config_prescaler+0x6c>
 1e2:	44 c0       	rjmp	.+136    	; 0x26c <TIM_config_prescaler+0xf4>
        switch (presc_val) {
 1e4:	63 30       	cpi	r22, 0x03	; 3
 1e6:	d1 f0       	breq	.+52     	; 0x21c <TIM_config_prescaler+0xa4>
 1e8:	68 f4       	brcc	.+26     	; 0x204 <TIM_config_prescaler+0x8c>
 1ea:	66 23       	and	r22, r22
 1ec:	99 f0       	breq	.+38     	; 0x214 <TIM_config_prescaler+0x9c>
 1ee:	61 30       	cpi	r22, 0x01	; 1
 1f0:	69 f5       	brne	.+90     	; 0x24c <TIM_config_prescaler+0xd4>
                TCCR1B = TCCR1B & ~_BV(CS11);
                TCCR1B = TCCR1B |  _BV(CS10);
                break;
            case TIM_PRESC_8:
                /* 010 */
                TCCR1B = TCCR1B & ~_BV(CS12);
 1f2:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 1f6:	8b 7f       	andi	r24, 0xFB	; 251
 1f8:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
                TCCR1B = TCCR1B |  _BV(CS11);
 1fc:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 200:	82 60       	ori	r24, 0x02	; 2
 202:	2c c0       	rjmp	.+88     	; 0x25c <TIM_config_prescaler+0xe4>
                TCCR0B = TCCR0B & ~_BV(CS00);
        }
    }
    /* Timer/Counter1 */
    else if (timer_name == TIM1) {
        switch (presc_val) {
 204:	65 30       	cpi	r22, 0x05	; 5
 206:	99 f0       	breq	.+38     	; 0x22e <TIM_config_prescaler+0xb6>
 208:	66 30       	cpi	r22, 0x06	; 6
 20a:	01 f5       	brne	.+64     	; 0x24c <TIM_config_prescaler+0xd4>
                TCCR1B = TCCR1B & ~_BV(CS11);
                TCCR1B = TCCR1B & ~_BV(CS10);
                break;
            case TIM_PRESC_1024:
                /* 101 */
                TCCR1B = TCCR1B |  _BV(CS12);
 20c:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 210:	84 60       	ori	r24, 0x04	; 4
 212:	11 c0       	rjmp	.+34     	; 0x236 <TIM_config_prescaler+0xbe>
    /* Timer/Counter1 */
    else if (timer_name == TIM1) {
        switch (presc_val) {
            case TIM_PRESC_1:
                /* 001 */
                TCCR1B = TCCR1B & ~_BV(CS12);
 214:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 218:	8b 7f       	andi	r24, 0xFB	; 251
 21a:	0d c0       	rjmp	.+26     	; 0x236 <TIM_config_prescaler+0xbe>
                TCCR1B = TCCR1B |  _BV(CS11);
                TCCR1B = TCCR1B & ~_BV(CS10);
                break;
            case TIM_PRESC_64:
                /* 011 */
                TCCR1B = TCCR1B & ~_BV(CS12);
 21c:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 220:	8b 7f       	andi	r24, 0xFB	; 251
 222:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
                TCCR1B = TCCR1B |  _BV(CS11);
 226:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 22a:	82 60       	ori	r24, 0x02	; 2
 22c:	09 c0       	rjmp	.+18     	; 0x240 <TIM_config_prescaler+0xc8>
                TCCR1B = TCCR1B |  _BV(CS10);
                break;
            case TIM_PRESC_256:
                /* 100 */
                TCCR1B = TCCR1B |  _BV(CS12);
 22e:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 232:	84 60       	ori	r24, 0x04	; 4
 234:	0e c0       	rjmp	.+28     	; 0x252 <TIM_config_prescaler+0xda>
                TCCR1B = TCCR1B & ~_BV(CS11);
                TCCR1B = TCCR1B & ~_BV(CS10);
                break;
            case TIM_PRESC_1024:
                /* 101 */
                TCCR1B = TCCR1B |  _BV(CS12);
 236:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
                TCCR1B = TCCR1B & ~_BV(CS11);
 23a:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 23e:	8d 7f       	andi	r24, 0xFD	; 253
 240:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
                TCCR1B = TCCR1B |  _BV(CS10);
 244:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 248:	81 60       	ori	r24, 0x01	; 1
 24a:	0d c0       	rjmp	.+26     	; 0x266 <TIM_config_prescaler+0xee>
                break;
            default:
                /* 000: No clock source (Timer/Counter stopped) */
                TCCR1B = TCCR1B & ~_BV(CS12);
 24c:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 250:	8b 7f       	andi	r24, 0xFB	; 251
 252:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
                TCCR1B = TCCR1B & ~_BV(CS11);
 256:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 25a:	8d 7f       	andi	r24, 0xFD	; 253
 25c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
                TCCR1B = TCCR1B & ~_BV(CS10);
 260:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 264:	8e 7f       	andi	r24, 0xFE	; 254
 266:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 26a:	08 95       	ret
        }
    }
    /* Timer/Counter2 */
    else {
        switch (presc_val) {
 26c:	86 2f       	mov	r24, r22
 26e:	90 e0       	ldi	r25, 0x00	; 0
 270:	87 30       	cpi	r24, 0x07	; 7
 272:	91 05       	cpc	r25, r1
 274:	48 f5       	brcc	.+82     	; 0x2c8 <TIM_config_prescaler+0x150>
 276:	fc 01       	movw	r30, r24
 278:	ec 5c       	subi	r30, 0xCC	; 204
 27a:	ff 4f       	sbci	r31, 0xFF	; 255
                TCCR2B = TCCR2B |  _BV(CS21);
                TCCR2B = TCCR2B & ~_BV(CS20);
                break;
            case TIM_PRESC_1024:
                /* 111 */
                TCCR2B = TCCR2B |  _BV(CS22);
 27c:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
                TCCR1B = TCCR1B & ~_BV(CS10);
        }
    }
    /* Timer/Counter2 */
    else {
        switch (presc_val) {
 280:	0c 94 a7 01 	jmp	0x34e	; 0x34e <__tablejump2__>
            case TIM_PRESC_1:
                /* 001 */
                TCCR2B = TCCR2B & ~_BV(CS22);
 284:	8b 7f       	andi	r24, 0xFB	; 251
 286:	07 c0       	rjmp	.+14     	; 0x296 <TIM_config_prescaler+0x11e>
                TCCR2B = TCCR2B & ~_BV(CS21);
                TCCR2B = TCCR2B |  _BV(CS20);
                break;
            case TIM_PRESC_8:
                /* 010 */
                TCCR2B = TCCR2B & ~_BV(CS22);
 288:	8b 7f       	andi	r24, 0xFB	; 251
 28a:	0c c0       	rjmp	.+24     	; 0x2a4 <TIM_config_prescaler+0x12c>
                TCCR2B = TCCR2B |  _BV(CS21);
                TCCR2B = TCCR2B & ~_BV(CS20);
                break;
            case TIM_PRESC_32:
                /* 011 */
                TCCR2B = TCCR2B & ~_BV(CS22);
 28c:	8b 7f       	andi	r24, 0xFB	; 251
 28e:	11 c0       	rjmp	.+34     	; 0x2b2 <TIM_config_prescaler+0x13a>
                TCCR2B = TCCR2B |  _BV(CS21);
                TCCR2B = TCCR2B |  _BV(CS20);
                break;
            case TIM_PRESC_64:
                /* 100 */
                TCCR2B = TCCR2B |  _BV(CS22);
 290:	84 60       	ori	r24, 0x04	; 4
 292:	1d c0       	rjmp	.+58     	; 0x2ce <TIM_config_prescaler+0x156>
                TCCR2B = TCCR2B & ~_BV(CS21);
                TCCR2B = TCCR2B & ~_BV(CS20);
                break;
            case TIM_PRESC_128:
                /* 101 */
                TCCR2B = TCCR2B |  _BV(CS22);
 294:	84 60       	ori	r24, 0x04	; 4
 296:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
                TCCR2B = TCCR2B & ~_BV(CS21);
 29a:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 29e:	8d 7f       	andi	r24, 0xFD	; 253
 2a0:	0d c0       	rjmp	.+26     	; 0x2bc <TIM_config_prescaler+0x144>
                TCCR2B = TCCR2B |  _BV(CS20);
                break;
            case TIM_PRESC_256:
                /* 110 */
                TCCR2B = TCCR2B |  _BV(CS22);
 2a2:	84 60       	ori	r24, 0x04	; 4
 2a4:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
                TCCR2B = TCCR2B |  _BV(CS21);
 2a8:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 2ac:	82 60       	ori	r24, 0x02	; 2
 2ae:	14 c0       	rjmp	.+40     	; 0x2d8 <TIM_config_prescaler+0x160>
                TCCR2B = TCCR2B & ~_BV(CS20);
                break;
            case TIM_PRESC_1024:
                /* 111 */
                TCCR2B = TCCR2B |  _BV(CS22);
 2b0:	84 60       	ori	r24, 0x04	; 4
 2b2:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
                TCCR2B = TCCR2B |  _BV(CS21);
 2b6:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 2ba:	82 60       	ori	r24, 0x02	; 2
 2bc:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
                TCCR2B = TCCR2B |  _BV(CS20);
 2c0:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 2c4:	81 60       	ori	r24, 0x01	; 1
 2c6:	0d c0       	rjmp	.+26     	; 0x2e2 <TIM_config_prescaler+0x16a>
                break;
            default:
                /* 000: No clock source (Timer/Counter stopped) */
                TCCR2B = TCCR2B & ~_BV(CS22);
 2c8:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 2cc:	8b 7f       	andi	r24, 0xFB	; 251
 2ce:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
                TCCR2B = TCCR2B & ~_BV(CS21);
 2d2:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 2d6:	8d 7f       	andi	r24, 0xFD	; 253
 2d8:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
                TCCR2B = TCCR2B & ~_BV(CS20);
 2dc:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 2e0:	8e 7f       	andi	r24, 0xFE	; 254
 2e2:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7e00b1>
 2e6:	08 95       	ret

000002e8 <TIM_config_interrupt>:
/*--------------------------------------------------------------------*/
void TIM_config_interrupt(uint8_t timer_name,
                          uint8_t interr_mode)
{
    /* Timer/Counter0 */
    if (timer_name == TIM0) {
 2e8:	81 11       	cpse	r24, r1
 2ea:	0c c0       	rjmp	.+24     	; 0x304 <TIM_config_interrupt+0x1c>
        switch (interr_mode) {
            case TIM_OVERFLOW_ENABLE:
                TIMSK0 = TIMSK0 | _BV(TOIE0);
                break;
            case TIM_OVERFLOW_DISABLE:
                TIMSK0 = TIMSK0 & ~_BV(TOIE0);
 2ec:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
void TIM_config_interrupt(uint8_t timer_name,
                          uint8_t interr_mode)
{
    /* Timer/Counter0 */
    if (timer_name == TIM0) {
        switch (interr_mode) {
 2f0:	66 23       	and	r22, r22
 2f2:	21 f0       	breq	.+8      	; 0x2fc <TIM_config_interrupt+0x14>
 2f4:	61 30       	cpi	r22, 0x01	; 1
 2f6:	11 f4       	brne	.+4      	; 0x2fc <TIM_config_interrupt+0x14>
            case TIM_OVERFLOW_ENABLE:
                TIMSK0 = TIMSK0 | _BV(TOIE0);
 2f8:	81 60       	ori	r24, 0x01	; 1
 2fa:	01 c0       	rjmp	.+2      	; 0x2fe <TIM_config_interrupt+0x16>
                break;
            case TIM_OVERFLOW_DISABLE:
                TIMSK0 = TIMSK0 & ~_BV(TOIE0);
 2fc:	8e 7f       	andi	r24, 0xFE	; 254
 2fe:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
                break;
 302:	08 95       	ret
                /* Disable overflow interrupt */
                TIMSK0 = TIMSK0 & ~_BV(TOIE0);
        }
    }
    /* Timer/Counter1 */
    else if (timer_name == TIM1) {
 304:	81 30       	cpi	r24, 0x01	; 1
 306:	61 f4       	brne	.+24     	; 0x320 <TIM_config_interrupt+0x38>
        switch (interr_mode) {
            case TIM_OVERFLOW_ENABLE:
                TIMSK1 = TIMSK1 | _BV(TOIE1);
                break;
            case TIM_OVERFLOW_DISABLE:
                TIMSK1 = TIMSK1 & ~_BV(TOIE1);
 308:	80 91 6f 00 	lds	r24, 0x006F	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
                TIMSK0 = TIMSK0 & ~_BV(TOIE0);
        }
    }
    /* Timer/Counter1 */
    else if (timer_name == TIM1) {
        switch (interr_mode) {
 30c:	66 23       	and	r22, r22
 30e:	21 f0       	breq	.+8      	; 0x318 <TIM_config_interrupt+0x30>
 310:	61 30       	cpi	r22, 0x01	; 1
 312:	11 f4       	brne	.+4      	; 0x318 <TIM_config_interrupt+0x30>
            case TIM_OVERFLOW_ENABLE:
                TIMSK1 = TIMSK1 | _BV(TOIE1);
 314:	81 60       	ori	r24, 0x01	; 1
 316:	01 c0       	rjmp	.+2      	; 0x31a <TIM_config_interrupt+0x32>
            case TIM_OVERFLOW_DISABLE:
                TIMSK1 = TIMSK1 & ~_BV(TOIE1);
                break;
            default:
                /* Disable overflow interrupt */
                TIMSK1 = TIMSK1 & ~_BV(TOIE1);
 318:	8e 7f       	andi	r24, 0xFE	; 254
 31a:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
 31e:	08 95       	ret
        switch (interr_mode) {
            case TIM_OVERFLOW_ENABLE:
                TIMSK2 = TIMSK2 | _BV(TOIE2);
                break;
            case TIM_OVERFLOW_DISABLE:
                TIMSK2 = TIMSK2 & ~_BV(TOIE2);
 320:	80 91 70 00 	lds	r24, 0x0070	; 0x800070 <__TEXT_REGION_LENGTH__+0x7e0070>
                TIMSK1 = TIMSK1 & ~_BV(TOIE1);
        }
    }
    /* Timer/Counter2 */
    else {
        switch (interr_mode) {
 324:	66 23       	and	r22, r22
 326:	21 f0       	breq	.+8      	; 0x330 <TIM_config_interrupt+0x48>
 328:	61 30       	cpi	r22, 0x01	; 1
 32a:	11 f4       	brne	.+4      	; 0x330 <TIM_config_interrupt+0x48>
            case TIM_OVERFLOW_ENABLE:
                TIMSK2 = TIMSK2 | _BV(TOIE2);
 32c:	81 60       	ori	r24, 0x01	; 1
 32e:	01 c0       	rjmp	.+2      	; 0x332 <TIM_config_interrupt+0x4a>
            case TIM_OVERFLOW_DISABLE:
                TIMSK2 = TIMSK2 & ~_BV(TOIE2);
                break;
            default:
                /* Disable overflow interrupt */
                TIMSK2 = TIMSK2 & ~_BV(TOIE2);
 330:	8e 7f       	andi	r24, 0xFE	; 254
 332:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x7e0070>
 336:	08 95       	ret

00000338 <main>:
#define BLINK_DELAY 1

int main(void)
{
 
  DDRB |=_BV(PB5);     
 338:	25 9a       	sbi	0x04, 5	; 4
  TIM_config_prescaler(TIM1, TIM_PRESC_1 );
 33a:	60 e0       	ldi	r22, 0x00	; 0
 33c:	81 e0       	ldi	r24, 0x01	; 1
 33e:	0e 94 bc 00 	call	0x178	; 0x178 <TIM_config_prescaler>
  TIM_config_interrupt(TIM1, TIM_OVERFLOW_ENABLE);
 342:	61 e0       	ldi	r22, 0x01	; 1
 344:	81 e0       	ldi	r24, 0x01	; 1
 346:	0e 94 74 01 	call	0x2e8	; 0x2e8 <TIM_config_interrupt>
  sei();
 34a:	78 94       	sei
 34c:	ff cf       	rjmp	.-2      	; 0x34c <main+0x14>

0000034e <__tablejump2__>:
 34e:	ee 0f       	add	r30, r30
 350:	ff 1f       	adc	r31, r31
 352:	05 90       	lpm	r0, Z+
 354:	f4 91       	lpm	r31, Z
 356:	e0 2d       	mov	r30, r0
 358:	09 94       	ijmp

0000035a <_exit>:
 35a:	f8 94       	cli

0000035c <__stop_program>:
 35c:	ff cf       	rjmp	.-2      	; 0x35c <__stop_program>
